## 六大设计原则

### 单一职责原则

定义

1. 一个类应该仅有一个引起它变化的原因

2. 如果一个类承担的职责过多，就相当于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力
   
- 类的复杂性降低
   - 可读性提高
   - 可维护性提高
   - 变更引起的风险降低
   
### 里氏替换原则

定义

所有引用基类的地方必须能够透明的使用其子类对象

约束：

- 子类必须完全实现父类的方法  
- 子类可以有自己的个性  
- 覆盖或实现父类的方法时输入参数可以被放大  
- 覆写或实现父类的方法时输出结果可以被缩小  

目的

采用里氏替换原则的目的就是增强程序的健壮性，即使增加子类，原有的子类还可以继续运行。

### 依赖倒置原则

核心思想：面向接口编程

定义

1. 高层模块不应该依赖低层模块， 两者都应该依赖其抽象；  

2. 抽象不应该依赖细节；

3. 细节应该依赖抽象  

在java中的体现

1. 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过
   接口或抽象类产生的  
2. 接口或抽象类不依赖于实现类；  
3. 实现类依赖接口或抽象类。  

### 接口隔离原则

定义

1. 接口要尽量小，但根据接口隔离原则拆分接口时， 首先必须满足单一职责原则  
2. 接口要高内聚  
   - 要求在接口中尽量少公布public方法， 接口是对外的承诺， 承诺越少对系统的开发越有利， 变更的风险也就越少， 同时也有利于降低成本  

### 迪米特原则

定义

尽量不要对外公布太多的public方法和非静态的public变量， 尽量内敛， 多使用private、 package-private、 protected等访问权限  

### 开放封闭原则

定义

一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭。  





## 设计模式

### UML类图

![image-20210319103706267](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319103706267.png)



### 1.工厂模式

由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例

![image-20210319105806593](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319105806593.png)

- 优点：
  - 一个调用者想创建一个对象，只要知道其名称就可以了
  - 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以
  - 屏蔽产品的具体实现，调用者只关心产品的接口

- 缺点：
  - 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事

### 2.抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

主要解决接口选择的问题。

![image-20210319110338440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319110338440.png)

- 优点
  - 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- 缺点
  - 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

### 3.策略模式

创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法

![image-20210319105027307](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319105027307.png)

- 优点：
  - 算法可以自由切换
  - 避免使用多重条件判断
  - 扩展性良好
- 缺点
  - 策略类会增多
  - 所有策略类都需要对外暴露

### 4.单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

![image-20210319113218247](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319113218247.png)

- 优点
  - 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例
  - 避免对资源的多重占用（比如写文件操作）
- 缺点
  - 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

### 5.建造者模式

将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

![image-20210319113746204](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319113746204.png)

- 优点
  - 建造者独立，易扩展
  - 便于控制细节风险
- 缺点
  - 产品必须有共同点，范围有限制
  - 如内部变化复杂，会有很多的建造类

### 6.原型模式

用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

![image-20210319115704496](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319115704496.png)

- 优点
  - 性能提高
  - 逃避构造函数的约束
- 缺点
  - 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候
  - 必须实现 Cloneable 接口
- 注意
  - 对象创建的形式
    - 使用new关键字(显式的调用构造函数)
    - 使用clone方法(在内存上对已有对象的影印 所以不会调用构造函数 )
    - 反射机制(显式的调用构造函数)
    - 反序列化(从文件中还原类的对象 也不会调用构造函数)

### 7.适配器模式

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

![image-20210319142051248](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319142051248.png)

- 优点
  - 可以让任何两个没有关联的类一起运行
  - 提高了类的复用
  - 增加了类的透明度
  - 灵活性好
- 缺点
  - 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构
  - 由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类

### 8.桥接模式

将抽象部分与实现部分分离，使它们都可以独立的变化。

在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。

![image-20210319145052609](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319145052609.png)

- 优点
  - 抽象和实现的分离
  - 优秀的扩展能力
  - 实现细节对客户透明
- 缺点
  - 桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。
- 使用场景
  - 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系
  - 对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用
  - 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展
- 注意事项
  - 对于两个独立变化的维度，使用桥接模式再适合不过了

### 9.组合模式

将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦

这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。

![image-20210319152924258](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319152924258.png)

- 优点
  - 高层模块调用简单
  - 节点自由增加
- 缺点
  - 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则

### 10.装饰器模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

![image-20210319153719343](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210319153719343.png)

- 优点
  - 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能
- 缺点
  - 多层装饰比较复杂

### 11.外观模式

外观模式隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

![image-20210322140910548](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322140910548.png)

- 优点
  - 减少系统相互依赖
  - 提高灵活性
  - 提高了安全性
- 缺点
  - 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适

### 12.享元模式

享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式

在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建



![image-20210322141825718](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322141825718.png)

- 优点
  - 大大减少对象的创建，降低系统的内存，使效率提高
- 缺点
  - 提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱

### 13.代理模式

在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

![image-20210322142408558](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322142408558.png)



- 优点
  - 职责清晰
  - 高扩展性
- 缺点
  - 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
  - 实现代理模式需要额外的工作，有些代理模式的实现非常复杂
- 注意事项
  - 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口
  - 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制

### 14.责任链模式

责任链模式为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推

![image-20210322143354095](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322143354095.png)

- 优点
  - 降低耦合度。它将请求的发送者和接收者解耦
  - 简化了对象。使得对象不需要知道链的结构
  - 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任
  - 增加新的请求处理类很方便
- 缺点
  - 不能保证请求一定被接收
  - 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用
  - 可能不容易观察运行时的特征，有碍于除错

### 15.命令模式

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令

在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适

将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化

![image-20210322144258819](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322144258819.png)

- 优点
  - 降低系统的耦合度
  - 新的命令可以很容易添加到系统中去
- 缺点
  - 使用命令模式可能会导致某些系统有过多的具体命令类

### 16.解释器模式

这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。

给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。

对于一些固定文法构建一个解释句子的解释器。

![image-20210322145233105](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322145233105.png)

- 优点
  - 可扩展性比较好，灵活
  - 增加了新的解释表达式的方式
  - 易于实现简单文法
- 缺点
  - 可利用场景比较少
  - 对于复杂的文法比较难维护
  - 解释器模式会引起类膨胀
  - 解释器模式采用递归调用方法

### 17.迭代器模式

提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示

不同的方式来遍历整个整合对象

![image-20210322150108085](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322150108085.png)

- 优点
  - 它支持以不同的方式遍历一个聚合对象
  - 迭代器简化了聚合类
  - 在同一个聚合上可以有多个遍历
  - 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码
- 缺点
  - 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性

### 18.中介者模式

用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理

![image-20210322151229329](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322151229329.png)

- 优点
  - 降低了类的复杂度，将一对多转化成了一对一
  - 各个类之间的解耦
  - 符合迪米特原则
- 缺点
  - 中介者会庞大，变得复杂难以维护

### 19.备忘录模式

备忘录模式保存一个对象的某个状态，以便在适当的时候恢复对象。

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态

所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态

![image-20210322151657384](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322151657384.png)

- 优点
  - 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态
  - 实现了信息的封装，使得用户不需要关心状态的保存细节
- 缺点
  - 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存

### 20.观察者模式

当一个对象被修改时，则会自动通知依赖它的对象

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知

![image-20210322152821538](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322152821538.png)

- 优点
  - 观察者和被观察者是抽象耦合的
  - 建立一套触发机制
- 缺点
  - 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
  - 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
  - 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化

### 21.状态模式

允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类

对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为

![image-20210322154023684](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322154023684.png)

- 优点
  - 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为
  - 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块
  - 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
- 缺点
  - 状态模式的使用必然会增加系统类和对象的个数
  - 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱
  - 状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码

### 22.访问者模式

主要将数据结构与数据操作分离

需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，使用访问者模式将这些封装到类中

![image-20210322161806972](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322161806972.png)

- 优点
  - 符合单一职责原则
  - 优秀的扩展性
- 缺点
  - 具体元素对访问者公布细节，违反了迪米特原则
  - 具体元素变更比较困难
  - 违反了依赖倒置原则，依赖了具体类，没有依赖抽象

### 23.模版模式

一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行

一些方法通用，却在每一个子类都重新写了这一方法

![image-20210322170016091](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322170016091.png)

- 优点
  - 封装不变部分，扩展可变部分
  - 提取公共代码，便于维护
  - 行为由父类控制，子类实现
- 缺点
  - 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大